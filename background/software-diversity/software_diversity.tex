\section{Software Diversity}

Software diversity is the study of diversity in software and software engineering. It is
a diverse discipline and there is a wide range of research all with different focus and
set of goals. The one common factor is that they all explore the potential benefits of
diverse engineering \cite{survey}.

Software diversity is a relatively common approach to certain security issues such as
memory errors exploits and different approaches have been taken. For example \textcite{os-randomization}
randomizes the interface between user space applications and the operating system, \textcite{mem-exploits}
introduces a level of indirection to function call to randomize static data at the C source
code level and \textcite{add-obfuscation} obfuscates the code and data of an executable by
randomizing the absolute locations.
% Stuff about memory errors
%\cite{os-randomization,mem-exploits,add-obfuscation,compiler-generated-sw-div}

Failing to defend against certain memory errors can introduce new attack vectors for a
determined adversary. Some of these attacks are based on the availability to reverse engineer
an vulnerable executable, where software diversity can once again prove an effective defense.
To defend against reverse-engineering \textcite{binary-stirring} dynamically determine the
addresses of basic blocks at load time, \textcite{smashing-gadgets} performs in-place code
randomization to make each executable look different without incurring significant overhead
and \textcite{librando} implements a library to transparently diversify code compiled and
executed by JIT-compilers.

Many more strategies and techniques exist for what is known as
\textit{automated software diversity} and \textcite{SoK} provides an overview of different
goals, attacks, defenses and deployment methods. \textit{Automated} refers to the fact that
a human is not involved in the process (other than devising the process).

% Stuff about ROP and other reverse engineering, code re-use attacks
%\cite{SoK,binary-stirring,large-scale-automated,readactor,smashing-gadgets,synthetic-diversity,librando},

What all of these techniques have in common is that they introduce some kind of chance into
the development toolchain, which will not be the approach taken in this paper. Instead
the focus will be on systematic and deterministic generation of \textit{static} diversity.
Static diversity entails generating several, diverse executables; In constrast to
\textit{dynamic} diversity which involves providing diverse runtimes\cite{survey}.

The motivation is that by employing diversification techniques one can break the
reactive nature of software security and shift the advantage from the attacker to the
defender \cite{compiler-generated-sw-div}, and by doing it without randomization one has
greater control over the process.

\subsection{Return Oriented Programming}
\label{rop}

\textcite{rop} introduces \textit{return-oriented programming} (ROP) as an extension of
the \textit{return-to-libc}\cite{return-into-libc} attack that allows arbitrary code
execution without the limitation of calling complete functions.

A typical return-into-libc attack involves somehow diverting the program control
flow to transfer control to code that already exists in the program's address space,
it could e.g be the system() library function, allowing the adversary to, for example, spawn
a shell without injecting any code. By first jumping to a sequence of instructions such as
"pop reg; pop reg; ret;" it is possible to chain together several of these function calls,
performing more complex operations \cite{non-exec-stack,advanced-return-into-libc}.

\textcite{rop} builds upon this concept by instead diverting the control flow to just a short
sequence of instruction, usually just two or three instructions, typically ending with a
"ret" instruction. These sequences are dubbed \textit{gadgets} and by carefully choosing
and chaining them together one can achieve arbitrary code execution \cite{rop}.

For instruction set architectures with varying instruction sizes there can be
\textit{hidden} gadgets. These are gadgets not placed there by the compiler. \textcite{rop}
explains them with an analogy to the English language; Where the word "dress" can be found
in "Address" and the word "head" can be found in "The Adress" depending on where you start
and stop reading. When instructions can be of varying lengths then the same sequence of
bytes can be interpreted as different instructions depending on where one starts reading.
If you can find a hidden "ret" instruction you can potentially find a whole gadget not
explicitly placed there by ther compiler.

\textcite{large-scale-automated} explored two static compiler techniques to break these
gadgets. By inserting NOP instructions randomly in the code and by randomizing the
instruction schedule they generate several semantically different, but functionally equal,
executables. Diversifying in this manner proved to be effective and they manage to break
the majority of gadgets \cite{large-scale-automated}. However, due to the inherent reliance
on chance there is no fine-grained control of the diversification process nor is there
any guarantee that the program structure is sufficiently different.
