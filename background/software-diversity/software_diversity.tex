\section{Software Diversity}

Software diversity is the study of diversity in software and software engineering. It is
a diverse discipline and there is a wide range of research all with different focus and
set of goals. The one common factor is that they all explore the potential benefits of
diverse engineering \cite{survey}.

Software diversity is a relatively common approach to certain security issues such as
memory errors exploits and different approaches have been taken. For example
\textcite{os-randomization} randomizes the interface between user space applications and
the operating system, \textcite{mem-exploits} introduces a level of indirection to function
call to randomize static data at the C source code level and \textcite{add-obfuscation}
obfuscates the code and data of an executable by randomizing the absolute locations.
% Stuff about memory errors
%\cite{os-randomization,mem-exploits,add-obfuscation,compiler-generated-sw-div}

Failing to defend against certain memory errors can introduce new attack vectors for a
determined adversary. Some of these attacks are based on the availiability to reverse engineer
an vulnerable executable, where software diversity can once again prove an effective defense.
\textcite{binary-stirring} dynamically determine the addresses of basic blocks at load time,
\textcite{smashing-gadgets} performs in-place code randomization to make each executable
look different without incurring significant overhead and \textcite{librando} implements
a library to transparently diversify code compiled and executed by JIT-compilers.

Many more strategies and techniques exist for what is known as
\textit{automated software diversity} and \textcite{SoK} provides an overview of different
attacks, defenses and deployment methods.

% Stuff about ROP and other reverse engineering, code re-use attacks
%\cite{SoK,binary-stirring,large-scale-automated,readactor,smashing-gadgets,synthetic-diversity,librando},

What all of these techniques have in common is that they introduce some kind of chance into
the development toolchain, which will not be the approach taken in this paper.

The motivation is that by employing diversification techniques one can break the
reactive nature of software security and shift the advantage from the attacker to the
defender \cite{compiler-generated-sw-div}, and by doing it without randomization one has
greater control over the process.

\subsection{Return Oriented Programming}
\label{rop}

\textcite{rop} introduces \textit{return-oriented programming} (ROP) as an extension of
the \textit{return-to-libc}\cite{return-into-libc} attack that allows arbitrary code
execution without the limitation of calling complete functions.

A typical return-into-libc attack involves somehow diverting the program control
flow to transfer control to code that already exists in the program's address space,
it could e.g be the system() library function, allowing the adversary to, for example, spawn
a shell without injecting any code. By first jumping to a sequence of instructions such as
"pop reg; pop reg; ret;" it is possible to chain together several of these function calls,
performing more complex operations \cite{non-exec-stack,advanced-return-into-libc}.

\textcite{rop} builds upon this concept by instead diverting the control flow to just a short
sequence of instruction, usually just two or three instructions, typically ending with a
"ret" instruction. These sequences are dubbed \textit{gadgets} and by carefully choosing
and chaining them together one can achieve arbitrary code execution \cite{rop}.

\textcite{large-scale-automated} explored two static compiler techniques to break these
gadgets. By inserting NOP instructions randomly in the code and by randomizing the
instruction schedule they generate several semantically different, but functionally equal,
executables. Diversifying in this manner proved to be effective and they manage to break
the majority of gadgets \cite{large-scale-automated}. However, due to the inherent reliance
on chance there is no fine-grained control of the diversification process nor is there
any guarantee that the program structure is sufficiently different.
