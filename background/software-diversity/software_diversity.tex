\section{Software Diversity}

Software diversity is the study of diversity in software and software engineering. It is
a diverse discipline and there is a wide range of research all with different focus and
set of goals. The one common factor is that they all explore the potential benefits of
diverse engineering \cite{survey}.

Software diversity is a relatively common approach to certain security issues such as
memory errors exploits \cite{os-randomization,mem-exploits,add-obfuscation,compiler-generated-sw-div}
as well as reverse-engineering based exploits (such as \textit{return-oriented programming}, see \ref{rop})
\cite{SoK,binary-stirring,large-scale-automated,readactor,smashing-gadgets,synthetic-diversity,librando},
the latter of which will be the focus of this paper. What all of these techniques have in
common is that they introduce some kind of chance into the development toolchain, which
will not be the approach taken in this paper.

The motivation is that by employing diversification techniques one can break the
reactive nature of software security and shift the advantage from the attacker to the
defender \cite{compiler-generated-sw-div}, and by doing it without randomization one has
greater control over the process.

\subsection{Return Oriented Programming}
\label{rop}

\textcite{rop} introduces \textit{return-oriented programming} (ROP) as an extension of
the \textit{return-to-libc}\cite{return-into-libc} attack that allows arbitrary code
execution without the limitation of calling complete functions.

A typical return-into-libc attack involves somehow diverting the program control
flow to transfer control to code that already exists in the program's address space,
it could e.g be the system() library function, allowing the adversary to, for example, spawn
a shell without injecting any code. By first jumping to a sequence of instructions such as
"pop reg; pop reg; ret;" it is possible to chain together several of these function calls,
performing more complex operations \cite{non-exec-stack,advanced-return-into-libc}.

\textcite{rop} builds upon this concept by instead diverting the control flow to just a short
sequence of instruction, usually just two or three instructions, typically ending with a
"ret" instruction. These sequences are dubbed \textit{gadgets} and by carefully choosing
and chaining them together one can achieve arbitrary code execution \cite{rop}.

\textcite{large-scale-automated} explored two static compiler techniques to break these
gadgets. By inserting NOP instructions randomly in the code and by randomizing the
instruction schedule they generate several semantically different, but functionally equal,
executables. Diversifying in this manner proved to be effective and they manage to break
the majority of gadgets \cite{large-scale-automated}. However, due to the inherent reliance
on chance there is no fine-grained control of the diversification process nor is there
any guarantee that the program structure is sufficiently different.
