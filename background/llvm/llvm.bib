@online {rubymotion,
	title = "Rubymotion Features",
	url = "http://www.rubymotion.com/tour/features/",
	urldate = "2018-02-08",
	organization = "Scratchwork Development LLC",
}

@online {ghc-backend,
	title = "The LLVM backend",
	url = "https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/LLVM",
	urldate = "2018-02-08",
	organization = "The Glasgow Haskell Compiler",
}

@online {rust-llvm,
	title = "rust-lang/llvm",
	url = "https://github.com/rust-lang/llvm",
	urldate = "2018-02-08",
	organization = "rust-lang",
}

@online {swift-llvm,
	title = "apple/swift-llvm",
	url = "https://github.com/apple/swift-llvm",
	urldate = "2018-02-08",
	organization = "Apple Inc.",
}

@online{clang,
	title = "clang: a C language family frontend for LLVM",
	url = "https://clang.llvm.org/",
	urldate = "2018-02-08",
	organization = "LLVM",
}

@online {llvm-overview,
	title = "LLVM Overview",
	url = "http://llvm.org/",
	urldate = "2018-02-08",
	organization = "LLVM",
}

@inbook {aosa-llvm,
	author = "Chris Lattner",
	booktitle = "The Architecture of Open Source Applications",
	volume = "1",
	year = "2012",
	editor = "Amy Brown and Greg Wilson",
	url = "http://www.aosabook.org/en/llvm.html",
	urldate = "2018-02-08",
	title = "LLVM",
}

@manual {llvm-writing-backend,
	title = "Writing an LLVM Backend",
	url = "https://llvm.org/docs/WritingAnLLVMBackend.html",
	urldate = "2018-02-08",
	organization = "LLVM",
}

@manual {llvm-mir-lang-ref,
	title = "Machine IR (MIR) Format Reference Manual",
	url = "https://releases.llvm.org/3.8.1/docs/MIRLangRef.html",
	urldate = "2018-02-08",
	organization = "LLVM",
}

@manual {llvm-codegenerator-highlevel,
	title = "The LLVM Target-Independent Code Generator",
	subtitle = "The high-level design of the code generator",
	url = "https://llvm.org/docs/CodeGenerator.html#the-high-level-design-of-the-code-generator",
	urldate = "2018-02-08",
	organization = "LLVM",
}

@manual {llvm-codegenerator-machinecode,
	title = "The LLVM Target-Independent Code Generator",
	subtitle = "Machine code description classes",
	url = "https://releases.llvm.org/3.8.1/docs/CodeGenerator.html#machine-code-representation",
	urldate = "2018-02-08",
	organization = "LLVM",
}

@manual {llvm-codegenerator-scheduling,
	title = "The LLVM Target-Independent Code Generator",
	subtitle = "SelectionDAG Scheduling and Formation Phase",
	url = "https://llvm.org/docs/CodeGenerator.html#scheduling-and-formation",
	urldate = "2018-02-08",
	organization = "LLVM",
}

@manual {llvm-codegenerator-bundles,
	title = "The LLVM Target-Independent Code Generator",
	subtitle = "MachineInstr Bundles",
	url = "https://llvm.org/docs/CodeGenerator.html#machineinstr-bundles",
	urldate = "2018-02-15",
	organization = "LLVM"
}

@manual {llvm-codegenerator-allocation,
	title = "The LLVM Target-Independent Code Generator",
	subtitle = "Register Allocation",
	url = "https://llvm.org/docs/CodeGenerator.html#register-allocator",
	urldate = "2018-02-08",
	organization = "LLVM",
}

@manual {llvm-llc,
	title = "llc - LLVM static compiler",
	url = "https://llvm.org/docs/CommandGuide/llc.html",
	urldate = "2018-06-01",
	organization = "LLVM",
}

@article {alloc-deconstructed,
	author = "David Ryan Koes and Seth Copen Goldstein",
	title = "Register Allocation Deconstructed",
	journaltitle = "12th International Workshop on Software \& Compilers for Embedded Systems",
	year = "2009",
	url = "https://llvm.org/pubs/2009-04-SCOPES-RegisterAllocationDeconstructed.pdf",
}

@article {combining-alloc-sched,
  title = "Combining register allocation and instruction scheduling",
  author = "Motwani, Rajeev and Palem, Krishna V and Sarkar, Vivek and Reyen, Salem",
	year = "1995",
	url = "http://i.stanford.edu/pub/cstr/reports/cs/tn/95/22/CS-TN-95-22.pdf",
}

@misc {welcome-to-backend,
	title = "2017 LLVM Developers’ Meeting: “Welcome to the back-end: The LLVM machine representation”",
	author = "Matthias Braun",
	url = "https://youtu.be/objxlZg01D0",
	year = "2017",
	type = "video",
	howpublished = "youtube",
	addendum = "~50-minute talk",
	urldate = "2018-02-08",
	organization = "LLVM",
}

@misc {inst-sched-cmu,
	title = "Introduction to Instruction Scheduling",
	author = "Peter Lee",
	year = "2006",
	url = "http://www.cs.cmu.edu/afs/cs/academic/class/15745-s06/web/handouts/11.pdf",
	type = "presentation",
	howpublished = "presentation slides",
	urldate = "2018-02-15",
	organization = "Carnegie Mellon University"
}

@misc {llvm-inst-sched-superscalar-vliw,
	title = "Instruction scheduling for Superscalar and VLIW platforms",
	author = "Andy Trick and Sergei Larin",
	year = "2012",
	url = "https://llvm.org/devmtg/2012-11/Larin-Trick-Scheduling.pdf",
	urldate = "2018-02-15",
	type = "presentation",
	howpublished = "presentation slides",
}

@book{caqa,
 author = {Hennessy, John L. and Patterson, David A.},
 title = {Computer Architecture, Fifth Edition: A Quantitative Approach},
 year = {2011},
 isbn = {9780123838728},
 edition = {5th},
 publisher = {Morgan Kaufmann Publishers Inc.},
 address = {San Francisco, CA, USA},
}

@InProceedings{integrated-sched-alloc-techniques,
author="Berson, David A.
and Gupta, Rajiv
and Soffa, Mary Lou",
editor="Chatterjee, Siddhartha
and Prins, Jan F.
and Carter, Larry
and Ferrante, Jeanne
and Li, Zhiyuan
and Sehr, David
and Yew, Pen-Chung",
title="Integrated Instruction Scheduling and Register Allocation Techniques",
booktitle="Languages and Compilers for Parallel Computing",
year="1999",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="247--262",
abstract="An algorithm for integrating instruction scheduling and register allocation must support mechanisms for detecting excessive register and functional unit demands and applying reductions for lessening these demands. The excessive demands for functional units can be detected by identifying the instructions that can execute in parallel, and can be reduced by scheduling some of these instructions sequentially. The excessive demands for registers can be detected on-the-fly while scheduling by maintaining register pressure values or may be detected prior to scheduling using an appropriate representation such as parallel interference graphs or register reuse dags. Reductions in excessive register demands can be achieved by live range spilling or live range splitting. However, existing integrated algorithms that are based upon mechanisms other than register reuse dags do not employ live range splitting. In this paper, we demonstrate that for integrated algorithms, register reuse dags are more effective than either on-the-fly computation of register pressure or interference graphs and that live range splitting is more effective than live range spilling. Moreover the choice of mechanisms greatly impacts on the performance of an integrated algorithm.",
isbn="978-3-540-48319-9"
}
