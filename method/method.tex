\chapter{Diversification with Unison}

The two strategies explored by \textcite{large-scale-automated} proved to be
effective and Unison is very capable of employing both of them. Specifically, the two
strategies where to randomize the instruction schedule and randomly inserting no-op
instructions. With Unison we have the opportunity to fine-tune them. For example, instead
of randomizing the entire instruction schedule we can focus on randomizing at a certain
distance from any return instructions.

Since these fine-grained strategies can be implemented as constraints we do not need to
consider if they can break program functionality, since if they do the constraint solver
will simply not find a solution at all.

\subsection{Constraining Difference}

The trivial strategy for diversification with Unison is to simply require all executables
to be \textit{different}. Unison can differ code in a few ways (see \ref{sec:unison}):

\begin{itemize}
	\item The order of the instructions is different
	\item The used registers are different
	\item Execute an copy using a different instruction (or not at all)
	\item Split live-ranges and spill temporaries differently
\end{itemize}

One of the techniques that will be evaluated is to simply require that all executables
are different \textit{in some way}. This would be the Unison equivalent of randomizing
the instruction schedule, but supposedly the diversity space will be larger as it will
entail more than just the instruction schedule.

\subsection{no-op Instructions}

To introduce even more possible combinations we can add an optional no-op instruction
between each of the original instructions. This would be the Unison equivalent of randomly
inserting no-ops. This technique can extend both the trivial constraint mentioned above
as well as the more fine-grained strategies.

\subsection{Fine-Grained Control}

\subsubsection{Diversify around the returns}

Since gadgets typically end in a "ret" instruction we can constrain solutions to be different
from a certain length from a "ret" instruction. This will most likely shrink our diversity
space, but hopefully it will also make more of an impact on the number of shared gadgets.

A problem with this approach is that gadgets are not necessarily found at the "ret"
instructions intentended by te compiler. Due to the nature of architectures with varying
instruction sizes one can possibly find gadgets by pointing to an address that is not
aligned with the intended assembly. In other words, a gadgets can be part of a function
prelude if one of those instructions can be partly read as "ret".

\subsubsection{}
