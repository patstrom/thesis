\chapter{Diversification with Unison}

The two strategies explored by \textcite{large-scale-automated} proved to be
effective and Unison is very capable of employing both of them. Specifically, the two
strategies where to randomize the instruction schedule and randomly inserting no-op
instructions.

Perhaps the most compelling reason to use a constraint solver for software diversity is that
for a combination to be considered a solution, \textit{all} constraints must be satisfied.
Regardless of what unorthodox strategy we want to try out we do not need to consider it's
effect on program functionality, since the constraints that ensure a valid program is
generated must still be satisfied.


\input{method/strategies.tex}

\section{Performance}

Unison's main purpose is to generate the most optimal solution. In an effort to achieve 
this Unison accepts the basic LLVM-solution as an optional parameter, and posts constraints
to only generate solutions that are \textit{better}. Better in this case is either that
they can be executed in fewer cycles or the size of the binary is smaller. Which is optimized
for is specified as a parameter.

For our purposes, we could limit our diversification strategies to only generate solutions
that execute in fewer (or the same amount of) cycles than the LLVM solution. In other words
we could generate executables with zero overhead \textit{with respect to LLVM's solution}.
Certain strategies would of course have an overhead, but with respect to the \textit{optimal
solution}.

\section{Architecture}

Unison does not currently support the x86 or x86-64 architecture. Only ARM, Hexagon and MIPS
are supported \cite{unison-src}. None of the supported architectures are complex instruction
set architecutres (at least in theory). Thus, hidden gadgets are not a problem. However,
regular gadgets are still present and for the purposes of systematic strategies for
diversity the supported architectures are sufficient.
