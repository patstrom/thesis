\section{Strategies}

For the purposes of this paper only a few strategies will be evaluated. The chosen
strategies are \textit{enumeration}, \textit{instruction schedule} and
\textit{register allocation}, and the motivation for each is presented in the respective
subsections.

As described in \ref{sec:unison} the problem of integrated register allocation and
instruction scheduling is modeled around \textit{operations} and \textit{operands}. The
problem consists of around 20 variables (see \ref{sec:constraint}) in total so only the
ones constrained will be presented for each strategy. These variables describe how the
operations and their operands relate to the actual instructions, temporaries, registers
and issue cycles.

\subsection{Enumeration}

The name of this strategy comes from the fact that we are only concerned that the solutions
are different, not how they differ. During search the Gecode search engine will never
explore the same combination twice, and thus never generate two equal solutions. The
strategy is thus to not post any constraints at all and let the solver generate all
possible combinations. We \textit{enumerate} the solutions.

Unison can differ the solutions in four main ways:

\begin{itemize}
	\item The order of the operations is different
	\item Operands are connected to different registers
	\item Execute a copy using a different instruction (or not at all)
	\item Split live-ranges and spill temporaries differently
\end{itemize}

The results of this strategy serve as a baseline for the program. It it literally happens
if we do nothing.

\subsection{Instruction Schedule}

Given the work of \textcite{large-scale-automated} we are given an opportunity to compare
systematic diversity to randomized diversity. Generating all possible schedules is directly
comparable to randomizing the instruction schedule. It is interesting to see how well
the systematic approach performs, and how it must be tweaked to achieve results similar
to the randomizing approach. Do note that this strategy is applied during the compilation
process and not on an already fixed instruction schedule. The strategy is not limited to
finding combinations of a set sequence of instructions; A shorter or longer schedule can
be generated.

There are two variables and one set of interest for this strategy. In the Unison documentation
they are described as follow:

\vspace{0.2cm}

\noindent\makebox[\textwidth]{
	\begin{tabular}{c|lr}
		\textbf{Type} & \textbf{Name} & \textbf{Description} \\ \hline
		\textbf{Set} & $O$ & The set of all operations in the program \\ \hline
		\multirow{3}{*}{\textbf{Variable}}
			& $a_o \in \{0, 1\}$ & whether operation \textit{o} is active (0 is false and 1 is true) \\
			& $c_o \in \mathbb{N}_0$ & issue cycle of operation \textit{o} \\
	\end{tabular}
}

\vspace{0.2cm}


In psuedo mathematical notation we want to post the constraint:

\vspace{0.2cm}
\noindent\makebox[\textwidth]{
	$\neg( (a_o = b.a_o) \land (c_m = b.c_m) ) \quad \forall o \in O, \forall m \in \{ O | b.a_m = 1 \}$
}
\vspace{0.2cm}

Very important to note is that the variables preceded by \textit{b.} (i.e $b.a_o$ and
$b.c_m$) represents an actual value. More precisely the value that is part of the previous
solution. For example $b.c_m$ represents the issue cycle of operation m in the previous
solution. The variables not preceded by \textit{b.} are variables in the constraint
programming sense and their corresponding domains make up the remaining combinations to
explore.

The constraint described with words is that we disallow the exact same combination of
active operations and their corresponding issue cycle. We are only concerned about the
issue cycle of the prvious solution's active operations, but we do take into account that
future solutions can have the same inctructions issued at the same cycles if it has fewer
or more active operations.

As mentioned in \ref{sec:unison}, some operations can be implemented by multiple
instructions. For the purpose of breaking gadgets we do not want to allow functionally
equivalent instructions. While they would indeed make the sequence of bytes differ, the
functionality would be the same and the gadget would survive.

\subsection{Registers}

The strategy to diversify the register allocation of the resulting binaries is an attractive
one due to causing no runtime overhead. Consequently, if it introduces significant diversity
it is an excellent candidate.

There are two variables and one set that are of concern when posting constraints on the register
allocation. Their description from the Unison documentation are as follows:

\vspace{0.2cm}

\noindent\makebox[\textwidth]{
	\begin{tabular}{c|lr}
		\textbf{Type} & \textbf{Name} & \textbf{Description} \\ \hline
		\textbf{Set} & $P$ & The set of all operands in the program \\ \hline
		\multirow{2}{*}{\textbf{Variable}}
			& $x_p \in \{0, 1\}$ & whether operand \textit{p} is connected (0 is false and 1 is true) \\
			& $ry_p \in \mathbb{N}_0$ & register to which operand \textit{p} is assigned \\
	\end{tabular}
}

\vspace{0.2cm}

In order to disallow the same register allocation we post the constraint:

\vspace{0.2cm}
\noindent\makebox[\textwidth]{
	$\neg( (x_p = b.x_p) \land (ry_p = b.ry_p) ) \quad \forall p \in P$
}
\vspace{0.2cm}

In words; We disallow the exact same combination of connected (used) operands and
operand to register mapping.

Just as for the instruction schedule constraint, the variables preceded by \textit{b.}
represents the actual value that is part of the previous solution, whereas the ones not
preceded by \textit{b.} are the constraint programming variables used when searching for
future solutions.
