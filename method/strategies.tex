\section{Strategies}

For the purposes of this paper only a few strategies will be evaluated. When exploring
combinations with a constraint solver similar solutions are found close to each-other (in-time).
The number of possible combinations for certain strategies might be far too large to handle
efficiently so when limiting the number of binaries generated it is beneficial to discard
an amount of binaries in between those actually written to disk. The contrasting approach
is of course to stop the search after X amount of solutions are found or Y amount of time
has passed, in which case the solutions might be too similar.


\subsection{Constraining Difference}

The trivial strategy for diversification with Unison is to simply require all executables
to be \textit{different}. Unison can differ code in a few ways (see \ref{sec:unison}):

\begin{itemize}
	\item The order of the instructions is different
	\item Temporaries are connected to different registers
	\item Execute a copy using a different instruction (or not at all)
	\item Split live-ranges and spill temporaries differently
\end{itemize}

The triviality of this strategy comes from the ease of implementation. We simply don't post
any more constraints when branching, which will cause all valid binaries to be generated.

This strategy is expected to have \textit{a lot} of solutions. Several millions of them
for a large input.
\subsection{Instruction Schedule}

For reference diversifying the instruction schedule will be implemented. This would be
the equivalent of randomizing the instruction schedule. It is intereseting to see the size
of the diversity space (i.e number of binaries that can be generated) and how different the
schedule must be to achieve results similar to \textcite{large-scale-automaed}.

Unison operates by creating an abstract construct, an \textit{operation}, for every instruction
in the MIR input. One reason for this is that some instructions can be replaced with another
instruction and be functionally equivalent, but (hopefully) faster. In other words some operations
can be implemented by several instructions. When implementing the diversification of the
instruction schedule this is taken into account and the constraints posted when a solution
is found entails making sure that future solutions do not have the same sequence of
operations, and if they do that at least one operation is impemented by another instruction.

\subsection{Registers}

Constraining each binary to allocate registers in a different way is, if sufficient, an
attractive strategy due to causing no overhead. The downside for a production release is
minimal since there are usually no use-cases where knowing the register allocation is required.
