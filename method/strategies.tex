\section{Strategies}

For the purposes of this paper only a few strategies will be evaluated. The chosen
strategies are \textit{difference}, \textit{instruction schedule} and
\textit{register allocation}, and the motivation for each is presented in the respective
subsections.

As described in \ref{sec:unison} the problem of integrated register allocation and
instruction scheduling is modeled around \textit{operations} and \textit{operands}. The
problem consists of around 20 variables (see \ref{sec:constraint}) in total so only the
ones constrained will be presented for each strategy. These variables describe how the
operations and their operands relate to the actual instructions, temporaries, registers
and issue cycles.

\subsection{Difference}

The name of this strategy comes from the fact that we are only concerned that the solutions
are different, not how they differ. During search the Gecode search engine will never
explore the same combination twice, and thus never generate two equal solutions. The
strategy is thus to not post any constraints at all and let the solver generate all
possible combinations.

Unison can differ the solutions in four main ways:

\begin{itemize}
	\item The order of the operations is different
	\item Operands are connected to different registers
	\item Execute a copy using a different instruction (or not at all)
	\item Split live-ranges and spill temporaries differently
\end{itemize}

The results of this strategy serve as a baseline for the program. It shows us how many
executables Unison can, at most, generate for the program. In other words, the biggest
diversity space for a given program (when using Unison).

\subsection{Instruction Schedule}

Given the work of \textcite{large-scale-automated} we are given an opportunity to compare
systematic diversity to randomized diversity. Generating all possible schedules is directly
comparable to randomizing the instruction schedule. It is interesting to see how well
the systematic approach performs, and how it must be tweaked to achieve results similar
to the randomizing approach.

There are three variables and two sets of interest for this strategy. In the Unison documentation
they are described as follow:

\vspace{0.2cm}

\noindent\makebox[\textwidth]{
	\begin{tabular}{c|lr}
		\textbf{Type} & \textbf{Name} & \textbf{Description} \\ \hline
		\multirow{2}{*}{\textbf{Set}}
			& $O$ & The set of all operations in the program \\
			& $instrs(o)$ & Set of instructions that can implement operation \textit{o} \\ \hline
		\multirow{3}{*}{\textbf{Variable}}
			& $a_o \in \{0, 1\}$ & whether operation \textit{o} is active (0 is false and 1 is true) \\
			& $i_o \in instrs(o)$ & instruction that implements operation \textit{o}  \\
			& $c_o \in \mathbb{N}_0$ & issue cycle of operation \textit{o} \\
	\end{tabular}
}

\vspace{0.2cm}

There are two aspects to diversifying the instruction schedule; Either the sequence of
operations is different, or if they are equal at least one operation is implemented by a
different instruction.

In psuedo mathematical notation we want to post the constraint:

\vspace{0.2cm}
\noindent\makebox[\textwidth]{
	$\neg( (a_o = b.a_o) \land (i_m = b.i_m) \land (c_m = b.c_m) ) \quad \forall o \in O, \forall m \in \{ O | b.a_m = 1 \}$
}
\vspace{0.2cm}

Very important to note is that the variables preceded by \textit{b.} (i.e $b.a_o$, $b.i_m$
and $b.c_m$) represents an actual value. More precisely the value that is part of the
previous solution. For example $b.c_m$ represents the issue cycle of operation m in the
previous solution. The variables not preceded by \textit{b.} are variables in the
constraint programming sense and their corresponding domains make up the remaining
combinations to explore.

The constraint described with words is that we disallow the exact same combination of
active operations, issue cycles and instructions that implement the operations. We are
only concerned about the issue cycles and implementing instruction of the previous
solution's active operations, but we do take into account that future solutions can have
the same instructions issued at the same cycles if it has fewer or more active operations.

\subsection{Registers}

The strategy to diversify the register allocation of the resulting binaries is an attractive
one due to causing no runtime overhead. Consequently, if it introduces significant diversity
it is an excellent candidate.

There are two variables and two sets that are of concern when posting constraints on the register
allocation. Their description from the Unison documentation are as follows:

\vspace{0.2cm}

\noindent\makebox[\textwidth]{
	\begin{tabular}{c|lr}
		\textbf{Type} & \textbf{Name} & \textbf{Description} \\ \hline
		\multirow{2}{*}{\textbf{Set}}
			& $P$ & The set of all operands in the program \\
			& $?$ & (Presumably) The set of available registers \\ \hline
		\multirow{2}{*}{\textbf{Variable}}
			& $x_p \in \{0, 1\}$ & whether operand \textit{p} is connected (0 is false and 1 is true) \\
			& $ry_p \in ?$ & register to which operand \textit{p} is assigned \\
	\end{tabular}
}

\vspace{0.2cm}

comment: The $ry_p$ variable is actually not part of the Unison manual so I don't know
exactly which set it is part of (presumably the set of all registers). Will talk to
Roberto and amend.

\vspace{0.2cm}

In order to disallow the same register allocation we post the constraint:

\vspace{0.2cm}
\noindent\makebox[\textwidth]{
	$\neg( (x_p = b.x_p) \land (ry_p = b.ry_p) ) \quad \forall p \in P$
}
\vspace{0.2cm}

In words; We disallow the exact same combination of connected (used) operands and
operand to register mapping.

Just as for the instruction schedule constraint, the variables preceded by \textit{b.}
represents the actual value that is part of the previous solution, whereas the ones not
preceded by \textit{b.} are the constraint programming variables used when searching for
future solutions.

