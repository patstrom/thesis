\section{Strategies}

When exploring combinations with a constraint solver similar solutions are found close to
each-other (in-time).  The number of possible combinations for certain strategies might be
far too large to handle efficiently so when limiting the number of binaries generated it is
beneficial to discard an amount of binaries in between those kept. The contrasting approach
is of course to stop the search after X amount of solutions are found or Y amount of time
has passed, in which case the solutions might be too similar.

For the purposes of this paper only a few strategies will be evaluated.

\subsection{Constraining Difference}

The trivial strategy for diversification with Unison is to simply require all executables
to be \textit{different}. Unison can differ code in a few ways (see \ref{sec:unison}):

\begin{itemize}
	\item The order of the instructions is different
	\item Temporaries are connected to different registers
	\item Execute a copy using a different instruction (or not at all)
	\item Split live-ranges and spill temporaries differently
\end{itemize}

The triviality of this strategy comes from the ease of implementation. We simply don't post
any more constraints when branching, which will cause all valid solutions to be generated.

This strategy is expected to have \textit{a lot} of solutions. Several millions of them
for a large input.

\subsection{Instruction Schedule}

For reference, diversifying the instruction schedule will be implemented. This would be
the equivalent of \textcite{large-scale-automated}'s randomizing of the instruction
schedule. It is interesting to see the size of the diversity space (i.e number of binaries
that can be generated) and how different the schedule must be to achieve similar results.

As described in \ref{sec:unison} Unison operates on \textit{operations} rather than
instructions, each of which can potentially be implemented by multiple instructions.
Diversifying the instruction schedule thus have two aspects to it; Either the sequence of
operations is different, or if they are equal at least one operation is implemented by a
different instruction.

\subsection{Registers}

Constraining each binary to allocate registers in a different way is, if sufficient, an
attractive strategy due to causing no overhead. The downside for a production release is
minimal since there are usually no use-cases where knowing the register allocation is required.

In addition to creating the abstract \textit{operation} construct for an instruction, a
similar construct is also created for the temporaries, aptly named an \textit{operand}.
An operand can be connected to different temporaries between different solutions. In other
words, to ensure different register allocation between solutions we post constraint that,
when satisfied, ensure that not all \textit{operands} are connected to the same temporaries,
and if they are, at least one temporary is allocated to a different register.
